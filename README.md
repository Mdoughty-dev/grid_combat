⚔️GRID COMBAT CHALLENGE

This repository contains the full setup for the Grid Combat Optimization problem, an original grid dynamic programming challenge involving health management and conditional movement. The player must navigate an n x n grid starting at the top-left corner and reach the bottom-right corner while maximizing the number of enemies defeated. Each cell in the grid contains either O for open space, H for a health pickup, or E for an enemy. Movement is restricted to right and down, with right from the last column wrapping to the first column of the next row. The player begins with H health, a global health cap H_max, a fixed enemy attack value A, and a health pickup value R. Entering an H cell restores R health up to H_max, while entering an E cell requires at least A health to win the fight; otherwise, the player is forced to move directly down one cell if possible. The forced-downward rule adds a layer of strategic complexity: if the forced cell also contains an enemy that the player cannot defeat, the path immediately becomes invalid. If the forced-down move would exceed the grid boundary, the path is also invalid. Health pickups apply immediately when entering their cell, including the starting position. The objective is to compute the maximum number of enemies that can be defeated along a valid path or print -1 if no such path exists.

For example, consider the following case: n = 3, Hstart = 5, Hcap = 10, A = 4, R = 3, and the grid layout as O E O, H E H, O O E. The player begins at (0,0) with 5 HP, moves right to (0,1) where E is present and wins the fight since 5 ≥ 4, losing 4 HP to end with 1 HP and one enemy defeated. Moving right again to (0,2) lands on O with 1 HP, then moving down to (1,2) gives a health pickup, restoring HP to 4. Finally, moving down to (2,2) encounters another enemy with HP 4 ≥ 4, defeating it and finishing with 0 HP and two total enemies defeated. The correct output for this case is 2.

The input format follows: n Hstart Hcap A R followed by n lines of n characters each representing the grid. Constraints are 1 ≤ n ≤ 500, 0 ≤ Hstart ≤ Hcap ≤ 5000, 1 ≤ A ≤ 5000, and 0 ≤ R ≤ 5000. The output is a single integer representing the maximum enemies defeated or -1 if no valid path exists.

This repository also includes three failed solution attempts generated using Qwen3-235B-A22B-2507 (with reasoning disabled). Each attempt demonstrates a different logical flaw in handling the forced-downward rule and dynamic state transitions. The first attempt uses a BFS structure but mishandles forced-down updates and wrapping logic, causing it to fail on all test cases. The second attempt improves structure but incorrectly updates health when consecutive enemies appear, leading to invalid overwriting of stronger states. The third attempt adds more consistent health tracking but still fails on chained forced-down sequences, incorrectly retaining outdated states that invalidate optimal paths. All three fail every test case by design, as part of the assignment requirement that no single model-generated attempt should pass.

The directory structure contains problem.md for the formal problem statement, idea.md for conceptual rationale and evolution, solution.cpp for the optimal accepted solution, solution_bf.cpp for the brute-force verifier (if used), and qwen/ containing the failed Qwen model runs along with conversation links. Test cases are under test_cases/, and requirements.json specifies time and space limits (for instance { "time": 2, "space": 512 }).

This problem was intentionally designed to appear approachable but reveal deeper computational nuances under the forced-down rule. It challenges both state design and correctness reasoning in grid-based DP and BFS formulations. The repository demonstrates how subtle rule interactions can systematically break naive implementations, offering a learning opportunity for algorithm design and model evaluation.
